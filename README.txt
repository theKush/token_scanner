//Purpose & Requirements: The purpose of this program is to tokeninze the input string from a text file. The program tokenizes the longest possible string possible. 
//                        If the input consists of any non-token string, the program should return "error"
//						  The program should should output if the token is a id, number, plus, minus, times, divide, assignment, left-parentheses, right-parenthese.
//						  The program ignores any comments in the input file. Also, program should not consider "read" and "write" as an id.


Scanner PseudocodeData Structure: Stack	inputStack[char] : stack created from breaking up input file into stack of characters	finalStack[strings]: stack created after performing scan function: includes comments	outputStack[string]: stack created from removing the comments from finalStack. 	LongestStack[char]: stack used to created longest possible tokenMain functions: scan, mainHelper functions: can_push, new_sate, removeComments, Valid_final_State, Break_up_into_stackEnumerate states: FRESH, ASSIGN, PLUS, MINUS, TIMES, DIV, LPAREN, RPAREN, ID, NUM, COMMENT, DOTNUM, CLOSECOMMENT, COLON.//input: text file//output: stack of strings outputStack[string]//perform the scan on the text file and output the stack of finals states created Main:	ask user for the input file name	read the whole text file and put it in a single string	break the string into stack of characters: inputStack	IF inputStack not empty		Perform the Scan(inputStack)		Create outputStack by removing comments		Print outputStack//Input: stack of characters inputStack[char]//output: stack of string: finalStack[string]Scan(inputStack): 	LongestStack[char] = stack of characters 		//used to create longest possible string	Set current state A = FRESH	WHILE true		IF inputStack is empty			Return finalStack		Remove White Spaces from the front of inputStack		IF top of inputStack is a valid character:				Set current state A = FRESH			WHILE can_push(current state A, top of inputStack)				Make longest possible token				IF inputStack is empty then BREAK			IF valid_final_state(A)				Push state A onto finalStack			ELSE				Not a valid state				Return Error				BREAK		ELSE			Not a valid characterReturn Error			BREAK//input: current character c, current state A//output: true if c can be pushed on to A, false if not.Can_push(A, c):	IF current character c can be pushed on to current state A to make the longest token		Return True	ELSE return False//input: current character c, current state A//output: new state when c is can be pushed on to ANew_state(A, c):	IF current character c can be pushed on to current state A		Return new state A//input: state A//output: true if A is a valid state, false if A is not a valid stateValid_final_State(A):	Check if state A is a final state//input: stack of string: finalStack[string]//output: stack of string that does not contain comments: outputStack[string]removeComments(finalStack):	remove comments from finalStack	Return outputStack//input: string s, stack of characters theStack//string s is broken down in to stack of characters and stored in theStackBreak_up_into_Stack(s, theStack):	WHILE theStack not empty		Empty theStack before use	FOR position = last character of string, repeat until you reach the first character		Push the character at current position on to theStack